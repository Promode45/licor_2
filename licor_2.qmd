---
title: "Untitled"
format: html
editor: visual
---

```{r}
#|echo: false
library(tidyverse)
library(janitor)
library(readr)
library(rstatix)
#install.packages("FSA")
library(FSA)
#install.packages("rcompanion")
library(rcompanion)
#install.packages("plotly")
library(plotly)
#install.packages("ggpubr")
library(ggpubr)
#install.packages("reshape")
library(reshape)
#install.packages("sciplot")
library(sciplot)
#install.packages("nlme")
library(nlme)
library(lme4)
library(emmeans)
library(broom)
library(multcomp)
library(car)

```

```{r}
#| echo: false
resp_data <- list.files(path = "/Users/pramodhegde/Library/CloudStorage/OneDrive-UniversityofGeorgia/Documents/Licor",
                        pattern = "*.csv",
                        full.names = T) %>% 
  lapply(read.csv, skip =3, header = F) %>% 
  bind_rows 
colnames(resp_data) <- c("co2", "date_time", "label", "swc", "flux", "ts", "ta")
resp_data_w <- resp_data %>% 
  na.omit() |> 
  filter(label != "Test")

```

The `echo: false` option disables the printing of code (only output is displayed).
```{r}
remove_outliers <- function(x, na.rm = TRUE, ...) {
  qnt <- quantile(x, probs=c(.25, .75), na.rm = na.rm, ...)
  H <- 1.5 * IQR(x, na.rm = na.rm)
  y <- x
  y[x < (qnt[1] - H)] <- NA
  y[x > (qnt[2] + H)] <- NA
  y
  print(y)
}
```

```{r}
resp_data_w <- resp_data_w %>% 
  clean_names() %>% 
  mutate(date_time = as.POSIXct(date_time, tz = Sys.timezone(), format="%Y/%m/%d %H:%M:%S")) %>% 
  mutate(label = factor(label)) %>% 
  mutate(day = day(date_time)) %>% 
  mutate(month = month(date_time)) %>% 
  mutate(treatment = case_when( label %in% c(1,8,12,20,23) ~ "Disturbance",
                                label %in% c(3,10,14,17,24,2,9,11,19,25) ~ "NPK",
                                label %in% c(4,7,15,16,22) ~ "Control", 
                                label %in% c(5,6,13,18,21) ~ "NPK+Disturbance",
                                .default = "Outside_treatments"
    )) |> 
  mutate( drying_cycle = case_when( day ==29 & month == 01 ~ "1",
                                    day == 30 & month == 01 ~"1" ,
                                    day == 31 & month == 01 ~ "1", 
                                    day == 05 ~ "2", 
                                    day == 06 ~ "2", 
                                    day == 07 ~ "2",
                                    day == 27 & month == 03 ~ "3",
                                    day== 28 & month == 03 ~ "3",
                                    day == 29 & month == 03 ~ "3",
                                    day == 01 & month == 04 ~ "3", 
                                    month == 7 ~ "4", 
                                    month == 8 ~ "4",
                                    .default = "0"
                                    
    
    
    
  )) |> 
  mutate(dar = case_when(
    day ==29 & month == 01 ~ "1",
    day == 30 & month == 01 ~"2" ,
    day == 31 & month == 01 ~ "3",
    day == 05 ~ "1",
    day == 06 ~ "2",
    day == 07 ~ "3",
    day == 27 & month == 03 ~ "1",
     day== 28 & month == 03 ~ "2",
    day == 29 & month == 03 ~ "3",
    day == 01 & month == 04 ~ "6",
    day == 30 & month == 07 ~ "1",
     day == 31 & month == 07 ~ "2",
    day == 01 & month == 08 ~ "3",
    day == 02 & month == 08 ~ "4",
    .default = "0"
    
    
  )
           
           ) |> 
   mutate(
    rep = case_when
    (label %in% c(1:5) ~ "1",
    label %in%  c(6:10) ~ "2",
      label %in%  c(11:15) ~ "3",
      label %in%  c(16:20) ~ "4", 
      label %in%  c(21:25) ~ "5",
      .default = "None"
     )
  ) |> 
  mutate(fdar = factor(dar),
         treatment = factor(treatment),
         label = factor(label),
         rep = factor(rep)) |> 
  filter(!treatment == "Outside_treatments") |> 
  mutate(time = yday(date_time) - 28) |> 
  mutate(ftime = factor(time))
  
  #|> 
  mutate(time = case_when(day == 29 & month == 01 ~ "T0",
                                    day == 30 & month == 01 ~"T1" ,
                                    day == 31 & month == 01 ~ "T2", 
                                    day == 05 ~ "T3", 
                                    day == 06 ~ "T4", 
                                    day == 07 ~ "T5",
                                    day == 25 & month == 03 ~ "T6",
                                    day == 27 & month == 03 ~ "T7",
                                    day== 28 & month == 03 ~ "T8",
                                    day == 29 & month == 03 ~ "T9",
                                    day == 01 & month == 04 ~ "T10", 
                                    day == 30 & month == 7 ~ "T11", 
                                    day == 31 & month == 7 ~ "T12",
                                    day == 01 & month == 8 ~ "T13"
                                    day == 02 & month == 8 ~ "T14",
                                    .default = "0"
                                    
    
    
    
  ))

```
At each plot, three measurements were made. In some plots, one of the three readings seemed to be off due to instrument problems, these were corrected using the IQR method. values beyond the bounds were converted to the mean of the three readings. 

```{r}
multiplier <- 1.5
resp_data_w <- resp_data_w |> 
  group_by(label,day,month) |> 
  mutate(iqr = IQR(swc, na.rm = T)) |> 
  mutate(lower_bound = quantile(swc, 0.25)- iqr  , 
         upper_bound = quantile(swc, 0.75)+ iqr, 
         mean = mean(swc, na.rm = T)) |> 
  ungroup() |> 
  mutate(swc = case_when(swc < lower_bound ~ mean,
                         swc > upper_bound ~ upper_bound,
                         .default = swc
                         )) 
```

```{r}
resp_data_w |> 
  filter(!treatment == "Outside_treatments") |> 
  group_by(day,month) |> 
  ggplot(aes(treatment, flux))+
  geom_boxplot()
```

```{r}
resp_data_subset <- subset(resp_data_w, treatment != "Outside_treatments", select = c(treatment, flux))
lineplot.CI(x.factor = treatment, response = flux, data = resp_data_subset)
#ggsave("Output/linegraph_CI.jpg")
```
Homogeneity of variance
```{r}
leveneTest(flux~treatment, data = resp_data_w)
```
Cannot reject null-hypotheses, therefore we can say that the variances are same for the groups. We move forward with a parametric test (anova)

```{r}
hist(resp_data_w$flux)
qqPlot(final_dryingcycle$flux)
resp_data_w |> 
  filter(swc < 0.1)
```

```{r}
resp_data_w |> 
  filter(!treatment == "Outside_treatments") |> 
  ggscatter(x = "swc", y = "flux",
            color = "treatment", add = "reg.line")+
  stat_regline_equation(
    aes(label = paste(after_stat(eq.label), ..rr.label.., sep = "~~~~"), color = treatment))
```
 Not required - Kruskall-Wallis test
```{r}
kruskal.test(flux ~ treatment, data = resp_data_w)
pwc <- pairwise.wilcox.test(resp_data_w$flux, resp_data_w$treatment,
                            p.adjust.method = "BH")
dunnt <- dunnTest(x = resp_data_w$flux, g = resp_data_w$treatment, method = "bonferroni")
dunns <- dunnt$res
cld <- cldList(comparison = dunns$Comparison,
               p.value = dunns$P.adj,
               threshold = 0.05)
names(cld)[1] <- "treatment"

```

code chunk from [https://statsandr.com/blog/how-to-do-a-t-test-or-anova-for-many-variables-at-once-in-r-and-communicate-the-results-in-a-better-way/]
The below chunk does anova for each variable, if differences are found pairwise comparisons are done as well. 
Holm correction is applied to p-values to avoid false-positives
```{r}

# edit from here
library(ggstatsplot)
library(tibble)
dat <- resp_data_w
x <- "treatment"
cols <- 4:7 # the 4 continuous dependent variables
type <- "parametric" # given the large number of observations, we use the parametric version
paired <- F # FALSE for independent samples, TRUE for paired samples
# edit until here

# edit at your own risk
plotlist <-
  purrr::pmap(
    .l = list(
      data = list(as_tibble(dat)),
      x = x,
      y = as.list(colnames(dat)[cols]),
      plot.type = "box", # for boxplot
      type = type, # parametric or nonparametric
      pairwise.comparisons = TRUE, # to run post-hoc tests if more than 2 groups
      pairwise.display = "significant", # show only significant differences
      bf.message = FALSE, # remove message about Bayes Factor
      centrality.plotting = FALSE # remove central measure
    ),
    .f = ifelse(paired, # automatically use ggwithinstats if paired samples, ggbetweenstats otherwise
      ggstatsplot::ggwithinstats,
      ggstatsplot::ggbetweenstats
    ),
    violin.args = list(width = 0, linewidth = 0) # remove violin plots and keep only boxplots
  )

# print all plots together with statistical results
for (i in 1:length(plotlist)) {
  print(plotlist[[i]])
}
#ggsave("Output/anova_flux.jpg")
```
only final drying cycle
```{r}
final_dryingcycle <- resp_data_w |> 
  filter(drying_cycle == 4)

library(ggstatsplot)
library(tibble)
dat <- final_dryingcycle
x <- "treatment"
cols <- 4:7 # the 4 continuous dependent variables
type <- "parametric" # given the large number of observations, we use the parametric version
paired <- FALSE # FALSE for independent samples, TRUE for paired samples
# edit until here

# edit at your own risk
plotlist <-
  purrr::pmap(
    .l = list(
      data = list(as_tibble(dat)),
      x = x,
      y = as.list(colnames(dat)[cols]),
      plot.type = "box", # for boxplot
      type = type, # parametric or nonparametric
      pairwise.comparisons = TRUE, # to run post-hoc tests if more than 2 groups
      pairwise.display = "significant", # show only significant differences
      bf.message = FALSE, # remove message about Bayes Factor
      centrality.plotting = FALSE # remove central measure
    ),
    .f = ifelse(paired, # automatically use ggwithinstats if paired samples, ggbetweenstats otherwise
      ggstatsplot::ggwithinstats,
      ggstatsplot::ggbetweenstats
    ),
    violin.args = list(width = 0, linewidth = 0) # remove violin plots and keep only boxplots
  )

# print all plots together with statistical results
for (i in 1:length(plotlist)) {
  print(plotlist[[i]])
}

```
anova - to be continued later 

```{r}
options(contrasts = c("contr.sum", "contr.poly"))

mix_mod <- lme(flux ~ treatment *ftime,
               random = ~ 1| rep/label,
               data = resp_data_w)
mix_mod
Anova(mix_mod, type = 3)

mod2_ma <- lme(flux ~ treatment*ftime,
                random = ~1 |rep/label,
               correlation = corARMA(p = 1, q = 1),
                data = resp_data_w)

mod3_exp <- lme(flux ~ treatment*ftime,
                random = ~1 |rep/label,
               correlation = corExp(form = ~time),
                data = resp_data_w)
```

subsetting different drying cycles 
```{r}
event1 <- resp_data_w |> 
  filter(drying_cycle == 1) 

library(ggstatsplot)
library(ggpubr)

# boxplots of different treatments, with kruskal-wallis test for flux v/s treatment, and wilcox pairwise test. 
my_comparison <- list(c("Control", "NPK"), c("Control", "NPK+Disturbance"))
ggboxplot(event1, x = "treatment" , y = "flux",
          add = "jitter", color = "treatment")+
  geom_hline(yintercept = mean(event1$flux), linetype = 2)+
  stat_compare_means(method = "kruskal.test", label.y = 3.0)+
  stat_compare_means(ref.group = ".all.", label = "p.signif", hide.ns = T)

# line plot with the same variables as above
ggline(event1, x = "treatment" , y = "flux", add = "mean_se")+
  stat_compare_means(label.y = 2.0)+
  stat_compare_means(ref.group = ".all.", label = "p.signif", hide.ns = T, label.y = 1.5)


```
Boxplot of flux v/s days after rain with boxes of different colors based on the treatment
```{r}
ggboxplot(event1, x = "fdar", y = "flux", color = "treatment", add = "jitter")+
  stat_compare_means(aes(group = treatment))+
  stat_compare_means(aes(group = treatment),label = "p.signif", label.y = 1.7)

ggline(event1, x = "fdar", y = "flux", color = "treatment", add = "mean_se")+
  stat_compare_means(aes(group = treatment))+
  stat_compare_means(aes(group = treatment), label = "p.signif", label.y = 1.7)
  
```

